use std::env;
use std::fs;
use std::io::{self,Write};
use std::path::{Path,PathBuf};
use std::time::Instant;
use anyhow::{Context,Result};
use chrono::Local;
use crossterm::{cursor,execute,style::{Attribute,Color,Print,ResetColor,SetAttribute,SetForegroundColor},terminal::{Clear,ClearType},};
use figlet_rs::FIGfont;
use walkdir::WalkDir;
fn print_logo(text:&str,color:Color)->crossterm::Result<()>{let standard_font=FIGfont::standard().unwrap();let figure=standard_font.convert(text);let ascii=figure.map_or_else(||String::from(text),|f|f.to_string());execute!(io::stdout(),SetForegroundColor(color),SetAttribute(Attribute::Bold),Print(ascii),ResetColor,SetAttribute(Attribute::Reset),Print("\n"))?;io::stdout().flush().ok();Ok(())}
fn print_styled_line(color:Color,attr:Option<Attribute>,text:&str)->Result<()>{if let Some(a)=attr{execute!(io::stdout(),SetForegroundColor(color),SetAttribute(a),Print(text),SetAttribute(Attribute::Reset),ResetColor,Print("\n")).context("failed to print styled")?;}else{execute!(io::stdout(),SetForegroundColor(color),Print(text),ResetColor,Print("\n")).context("failed to print colored")?;}Ok(())}
fn pause_before_exit()->Result<()>{println!();print_styled_line(Color::DarkGrey,None,"Press Enter to exit...")?;let mut s=String::new();io::stdin().read_line(&mut s).ok();Ok(())}
fn bytes_to_mb(b:u128)->f64{(b as f64)/1024.0/1024.0}
fn dir_size_u128(path:&Path)->u128{if!path.exists(){return 0;}let mut total:u128=0;for entry in WalkDir::new(path).min_depth(1).into_iter().filter_map(|e|e.ok()){if let Ok(md)=entry.metadata(){if md.is_file(){total=total.saturating_add(md.len() as u128);}}}total}
fn dir_size_and_count(path:&Path)->(u128,usize){if!path.exists(){return (0,0);}let mut total:u128=0;let mut count:usize=0;for entry in WalkDir::new(path).min_depth(1).into_iter().filter_map(|e|e.ok()){if let Ok(md)=entry.metadata() {if md.is_file(){total=total.saturating_add(md.len()as u128);count+=1;}}}(total,count)}
fn delete_dir_contents(path:&Path)->Result<()>{if!path.exists(){return Ok(());}for entry in fs::read_dir(path).with_context(||format!("read_dir {}",path.display()))?{let entry=entry?;let p=entry.path();if p.is_dir() {if let Err(e)=fs::remove_dir_all(&p) {eprintln!("Failed remove_dir_all {}: {:?}",p.display(),e);}} else {if let Err(e)=fs::remove_file(&p){eprintln!("Failed remove_file {}: {:?}", p.display(), e);}}}Ok(())}
fn main()->Result<()>{execute!(io::stdout(),Clear(ClearType::All),cursor::MoveTo(0, 0))?;print_logo("TEMP CLEANER",Color::Red)?;println!("github.com/filza2");println!();print_styled_line(Color::Grey,None,&format!("Started at {}",Local::now().format("%Y-%m-%d %H:%M:%S")))?;println!();print_styled_line(Color::Cyan,Some(Attribute::Bold),"Preview the temporary folders below before deleting.")?;println!();let tmp = env::var_os("TEMP").map(PathBuf::from).or_else(||env::var_os("TMP").map(PathBuf::from)).unwrap_or_else(||env::temp_dir());let windows_temp=match env::var("WINDIR"){Ok(w)=>PathBuf::from(w).join("Temp"),Err(_) => PathBuf::from(r"C:\Windows\Temp"),};let (size_tmp,count_tmp)=dir_size_and_count(&tmp);let (size_win_tmp,count_win_tmp)=dir_size_and_count(&windows_temp);print_styled_line(Color::White,None,&format!("1) {}  — {} files — {:.2} MB",tmp.display(),count_tmp,bytes_to_mb(size_tmp)))?;print_styled_line(Color::White,None,&format!("2) {}  — {} files — {:.2} MB",windows_temp.display(),count_win_tmp,bytes_to_mb(size_win_tmp)))?;println!();print_styled_line(Color::Red,Some(Attribute::Bold),"Do you want to proceed and delete the contents of the above folders? (y/N)")?;print!("> ");io::stdout().flush().ok();let mut answer = String::new();io::stdin().read_line(&mut answer)?;let answer=answer.trim().to_lowercase();let started=Instant::now();let mut freed_bytes:u128=0;if answer=="y"||answer=="yes"{println!();let before_tmp=dir_size_u128(&tmp);if let Err(e)=delete_dir_contents(&tmp){eprintln!("Warning: failed cleaning {}: {:?}",tmp.display(),e);}let after_tmp=dir_size_u128(&tmp);freed_bytes=freed_bytes.saturating_add(before_tmp.saturating_sub(after_tmp));let before_win=dir_size_u128(&windows_temp);if let Err(e)=delete_dir_contents(&windows_temp){eprintln!("Warning: failed cleaning {}: {:?}", windows_temp.display(), e);}let after_win=dir_size_u128(&windows_temp);freed_bytes=freed_bytes.saturating_add(before_win.saturating_sub(after_win));let elapsed=started.elapsed();println!();print_styled_line(Color::Green, Some(Attribute::Bold),&format!("Cleanup finished in {:.2} seconds.",elapsed.as_secs_f64()))?;print_styled_line(Color::Green, Some(Attribute::Bold),&format!("Total freed: {:.2} MB",bytes_to_mb(freed_bytes)))?;}else{print_styled_line(Color::DarkYellow,None,"Aborted by user. No deletion performed.")?;}pause_before_exit()?;Ok(())}